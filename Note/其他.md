# Quartz

* 分为三个部分：
  * Job&Detial(任务)：定时任务的执行方法，与Trigger配套的
  * Trigger(触发器)：规定什么时候触发，与Job&Detail配套的
  * Scheduler(调度器)：单例，把Trigger丢里面由调度器调度，只需要一个Scheduler，配置不同的Trigger；可以理解成类似线程池的东西

* 原理：ScheduledThreadPoolExecutor线程池 + 通过Object类的wait()和notify()或者Condition类的await()\signal()进行等待和唤醒、锁保证线程安全 来进行调度

  Scheduler有两个调度线程：regular Scheduler Thread（执行常规调度）和Misfire Scheduler Thread（执行错失的任务），Regular Thread 轮询所有Trigger，如果有将要触发的Trigger（用wait和notifyAll实现），则从任务线程池中获取一个空闲线程，然后执行与改Trigger关联的job；Misfire Thraed则是扫描所有的trigger，查看是否有错失的，如果有的话，根据一定的策略进行处理

* 默认是并发的，即如果当前任务没有完成，会自动开一个任务执行

* 注意在分布式集群的情况下，多台机子有相同的定时任务，会出错，此时通过共享数据库的方式实现

  Quartz的解决方案：

  quartz集群分为水平集群和垂直集群，水平集群即将定时任务节点部署在不同的服务器，其最大的问题就是时钟同步问题，若时钟不能同步，则会导致集群中各个节点状态紊乱，造成不可预知的后果；垂直集群则是集群各节点部署在同一台服务器，时钟同步自然不是问题，但存在单点故障问题，服务器宕机会严重影响服务的可用性

  在各个节点会上报任务，存到数据库中，执行时会从数据库中取出触发器来执行，如果触发器的名称和执行时间相同，则只有一个节点去执行此任务。

  如果此节点执行失败，则此任务则会被分派到另一节点执行，中途也会自动检查失效的定时调度，发现不成功的，其他节点立马接过来继续完成定时任务。Quartz有11个定时任务调度表

参考

[Quartz原理解密](https://www.cnblogs.com/Dorae/p/9357180.html)

[深入解读Quartz的原理](https://blog.csdn.net/scgyus/article/details/79360316)

[Quartz 2.2 的实现原理和运行过程](https://blog.csdn.net/xlxxcc/article/details/52104463)

# 其他定时器

  * Timer：这是java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。一般用的较少。单线程，任务一多会阻塞；一个任务出异常其他任务都受影响；受系统时间影响
  * ScheduledExecutorService：也jdk自带的一个类；是基于线程池设计的定时任务类,每个调度任务都会分配到线程池中的一个线程去执行,也就是说,任务是并发执行,互不影响。线程池+延时队列DelayedQueue(数组、最小堆, 最近要执行的任务放在堆顶) 实现，如果堆顶任务时间未到就阻塞（通过自旋+condition.await\signal实现）。不受系统时间影响
  * Spring 中的 @Schedule  注解

参考：[Java 定时任务实现原理详解](https://blog.csdn.net/u013332124/article/details/79603943)

[Java优先级队列DelayedWorkQueue原理分析](https://www.jianshu.com/p/587901245c95)

# 负载均衡算法

* 轮询：按请求的顺序分配给各个服务器，适用于各台服务器性能相同
* 加权轮询：给各个服务器附上权重值，按权重的高低分配请求，适用于各台服务器性能不同，性能高的服务器权重也高
* 最少链接：将请求发送给当前最少连接数的服务器上
* 加权最少链接：在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数
* IP地址哈希：哈希均匀分布

# CORS

前后端分离的场景下，由于浏览器的同源策略，导致浏览器内的请求不同的源的后端是会失败，常见的解决跨域方法是使用CORS，现在常见的web框架都支持CORS，开启即可

解决跨域的方法除了CORS，还要jsonp，不过已经很少使用了，jsonp本质是利用浏览器允许加载不同源的js文件即<script>标签等，将跨域请求<script>标签里，返回一段可执行的js代码，其中包含了请求结果，通常是json格式，前端通过返回的js代码执行回调获取结果

详情见 [跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)

对于跨域产生的问题，如CSRF跨域请求攻击的解决方案，可参考：[美团:如何防止csrf](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)

# session和cookie

- 首先Http是无状态的，因此需要通过session、cookie来达到记录用户状态的目的。

- 传统的session、cookie：session存用户信息，保存在服务端中，cookie里存session对应的sessionId，保存在客户端中，用于找到对应的session，每次请求都会带上该cookie来表示此用户。

- 由于现在实例的部署不可能只部署一个，一般都是集群部署，因此session不可以只存在一个实例的内存中，因此引入Redis来存用户的登录信息

- 现在一般使用 token + Redis来实现session机制，前端的cookie更多的是存token的信息而已，一般也是把token的值放在请求头中，而不会把cookie发给后端

# JWT

- JWT = JSON WEB TOKEN

- JWT原理：JWT实际上是一个token(令牌)，分为三部分：Header(头部)、Payload(负载)、Signature(签名)。

Header(头部) 记录 Signature(签名) 的加密方式 和 本token的类型，一般是SHA256

Payload(负载) 记录用户登录信息(官方规范默认是不加密的，分为官方字段和私有字段）

Signature(签名) 记录 Header(头部)和Payload(负载)的公钥，自己本身使用Header(头部)里规定的方式加密

形成的方式：header使用base64URL编码 + "." +  payload使用base64URL编码 + "." +  签名()

一般用法，使用Header(头部)里的加密方式对Header(头部)的base64URL编码 + "." + Payload(负载) 使用base64URL编码 + "." + 保存在后端的密钥进行签名得到 Signature(签名)，最后组合成`base64URL(header) + "." + base64(payload) + "." + signature`，后端收到该JWT后验证该签名是否正确，来判断JWT里的用户信息是否可靠

可以存储在浏览器的本地缓存localStorage或者cookie中，发送请求的时候放在cookie里，或者放在请求头中

- JWT的目的是让服务器不保存任何session数据，让后端变成无状态的，因此没办法主动废弃某个token，一旦签发了JWT，在到期之前就会始终有效，如果想要实现这种功能，必然需要在后端保存JWT，就违背了JWT的意愿了。
- 要让JWT实现 续签 和 主动过期功能，必定需要在后端保存JWT
  - jwt主动过期问题，使用黑名单即可；分成两点，客户端要求失效，服务端记录token到黑名单；用户重置密码，服务端记录uid-time键值对，在此之前的token全部失效；客户端把保存的jwt删掉是没用的，此时的jwt依然有效，只是客户端没记录而已
  - jwt续签问题，一种解决方式是jwt中存储过期时间，服务端设置刷新时间，请求时判断是否在过期时间或刷新时间，在刷新时间内进行token刷新，失效token记入黑名单；
  - 而黑名单过大问题，可以采用记录UID-刷新时间方式解决，判断jwt签发时间，jwt签发时间小于UID-刷新时间的记为失效
- 个人认为JWT的生成方式本身是有一套规范的，在实际使用过程中也可以对他进行改动，本质上还是一个签名校验而已，比如使用Header(头部)里的加密方式加密Signature(签名)，Signature(签名)加密Header(头部) 和Payload(负载) 这两部分，服务器里的私钥解密Payload(负载)，得到需要的登录信息

JWT参考：[JWT 超详细分析](https://learnku.com/articles/17883)

# CAS模型 - SSO(单点登录)

可参考：[CAS实现单点登录SSO执行原理探究](https://blog.csdn.net/javaloveiphone/article/details/52439613)，讲得算是比较明白，这里是总结基于CAS模型改的单点登录模式

![基于OAuth2的第三方登录](https://github.com/Nixum/Java-Note/blob/master/Note/picture/基于oauth2的第三方登录流程.png)

# 基于OAuth2.0的第三方登录

可参考：[理解OAuth 2.0](https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)，这样基本就入门了，这里是总结项目中如何接入，一般在集成facebook和google的第三方登录也是类似的流程机制

第一次访问时，由于没有访问的token，会引导至登录

![第一次访问](https://github.com/Nixum/Java-Note/blob/master/Note/picture/sso-first-access.png)

再次访问Web-1时，由于前端已存了token，直接使用token进行请求即可

已登录Web-1时去访问Web-2，会通过后端认证中心实现单点登录

![第二次访问](https://github.com/Nixum/Java-Note/blob/master/Note/picture/sso-second-access.png)

