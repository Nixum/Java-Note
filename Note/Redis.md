[TOC]

# 数据类型及结构

[一文揭秘单线程的Redis为什么这么快?](https://zhuanlan.zhihu.com/p/57089960?utm_source=wechat_session&utm_medium=social&utm_oi=632939468966072320)

总结一下就是：存内存操作、非阻塞IO多路复用，避免频繁的上下文切换，高效的数据结构和数据压缩

# 与Memcached的区别

* Redis支持存储多种数据类型：string、list、hash、set、zset；而Memcached只支持string

* Redis支持持久化：RDB快照和AOF日志；Memcached不支持持久化

* Redis支持事务，使用MULTI 和 EXEC命令，支持流水线式发送命令 ；Memcahced不支持事务，命令只能一条一条的发

* Redis-Cluster 支持分布式存储，可以多台Redis服务器存储同样的数据；Memcached是以**一致性哈希算法**实现分布式存储，即多台Memcached服务器，Memcached根据查找的key计算出该数据在哪台服务器上

* 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘； 

  Memcached 的数据则会一直在内存中，Memcached使用固定空间分配，将内存分为一组大小不同的slab_class，每个slab_class又分为一组大小相同的slab，每个slab又包含一组大小相同的chunk，根据数据大小，放到不同的chunk里，这种管理方式避免内存碎片管理问题，但是会带来内存浪费，即每个chunk内会放小于这个chunk大小的数据，chunk里有些空间没利用到

  一致性哈希算法：构造一个长度为2的32次方的整数环，根据结点名称的Hash值([0，2^32-1])，将结点放置在这个Hash环上，根据数据的key值计算Hash值，在Hash环上顺时针查找距离这个Key的Hash值最近的结点，完成key到结点的Hash映射查找，这样当扩容结点时，只会影响到其中一个结点；为了解决负载不均衡问题，可以在此基础上增加一个虚拟层，key先在环上找到虚拟结点，再找到物理结点，将数据分散到各个结点，一般一个物理结点对应150个虚拟结点

# 过期时间和数据淘汰策略

## key过期删除原理

* 定期删除策略：Redis起定时器扫描key，判断key是否过期，过期则删除。虽然可以保证过期的key会被删除，但是每次都要扫面全表会非常消耗CPU资源，且定时器有间距，有可能出现key过期，但是此时定时器还没起，key仍保存在内存中
* 惰性删除策略：每次获取key的时候才判断key是否过期，过期则删除，但如果key一直未被使用，则会一直留在内存里，浪费空间
* 所以Redis会将这两种策略整合在一起，定期删除策略不在是每次都扫描全部key，而是随机抽取一部分key进行检查，在配合惰性删除策略，正好可以弥补惰性删除策略的缺点

## 淘汰策略

当内存使用量超出时，才会执行淘汰策略，默认的淘汰策略是当内存满了只会，新写入操作会报错。

其他淘汰策略

* 在所有key中，随机移除某个key
* 在所有有设置过期时间的key中，随机移除某个key
* 在所有key中，移除最近最少使用的key
* 在所有有设置过期时间的key中，移除最近最少使用的key
* 在所有有设置过期时间的key中，有更早过期时间的key优先移除

* 在所有key中，移除访问次数最少的某个key
* 在所有有设置过期时间的key中，移除访问次数最少的某个key

# 持久化

## 1. RDB快照

bgsave，会调子进程创建快照写入磁盘，父进程继续处理其他命令请求

save，主线程创建快照写入磁盘，会阻塞其他命令请求

redis.conf配置里，save [时间] [次数] 表示在[时间]内有[次数]写入，就会触发bgsave命令

另外，在进行主从复制，主redis发生sync命令给从redis时，如果刚刚没有执行完bgsave，也会进行一次bgsave操作。

## 2. AOF

写命令记录到文件中，默认是每秒同步一次，所以如果发生故障，最多会丢失一秒的数据，但使用AOF保存的数据文件比RDB快照要大。此外AOF还能选择每接收一个写命令就追加写入到AOF文件中，但这种对机器的负担较大，影响服务性能

## 主从复制

## 过程

一般用在从节点初始化加入时使用，先进行全量同步(通过快照)，在进行增量同步(通过命令缓存同步)

1. 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；
2. 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；
3. 主服务器每执行一次写命令，就向从服务器发送相同的写命令

一般只设置一个主节点，当负载上升时，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载，此时可以通过设置主节点为根节点，向下延申，从节点再设置从节点的方式，形成树状的主从链，让从节点帮忙同步给其子节点的方式，降低主节点的压力。

## 高可用方案

一般是使用哨兵机制（sentinel）来监听和管理Redis集群，存储集群配置，作用类似ZooKeeper，哨兵节点本身也是一台Redis，但功能有限，主要同来支持哨兵机制。

哨兵节点一般设置3个及以上的奇数个，哨兵节点间是平级的，会互相监控。不断检测Redis的主从节点是否正常运行，当有Redis节点出现问题时，进行通知，如果发生问题的节点是主节点，会从从节点中选出主节点，代替失效的主节点。

主观下线：每个哨兵节点每隔1s对主从节点发生心跳，当有节点再超过x秒后没有进行回复，此时该节点为主观下线，还需要进一步判断。

客观下线：当主观下线的节点是主节点时，该哨兵节点会通过sentinel is-master-down-by-addr命令，向其它哨兵节点询问对主节点的判断，当超过 y 个哨兵节点认为主节点有问题时，该节点为客观下线。

客观下线后，会从从节点中选举出主节点，前主节点重新上线后会被设置为从节点

Redis没有使用什么一致性算法，仅依据gossip协议在有效时间范围内收到其它Sentinel节点的确认。

# 事务

使用 MULTI 和 EXEC 命令将多个写操作包围起来，更多的是为了减少客户端与服务端的通信次数，无法实现事务的ACID特性

# 缓存可能引发的问题以及应对方法

## 缓存雪崩

现象：缓存大面积失效导致请求到达数据库

应对方法：

1. 缓存过期时间设置均匀，不能让一大片缓存在某一时间全部失效，比如设置过期时间时加入随机数，让过期时间在一个范围内波动
2. 请求时加锁(比如利用redission的rlock)，后续请求只能等到前面的查完数据库，进行缓存后，才能继续，但会造成吞吐量降低，响应时间变长，或者可以使用semaphore设置一定的信号量，不至于只有一个请求去回源数据库
3. 不设置key的过期时间，另开一个定时任务定期全量更新缓存；或者定时任务定期扫描，将快要过期的key延迟过期时间；设置多级缓存

## 缓存穿透

现象：查询一个一定不存在的数据，导致请求一直到达数据库

应对方法：

1. 使用布隆过滤器，将可能出现查询的值哈希到一个bitMap中，进行拦截，虽然布隆过滤有一定的误报几率，但也能一定程度的减少穿透的影响，常见的方案是配合2一起降低穿透带来的影响
2. 如果查询结果为空，也加入缓存中（可以直接设置为空，或者使用特殊标识来表示），并设置过期时间

## 缓存无底洞

现象：增加缓存节点，性能不升反降，原因是客户端要维护大量的连接，如果key分布在不同机器，需要查多次

应对方法：

1. 减少网络请求，能批量查尽量批量查
2. 将key进行分类，存到指定节点，查询同类的key时只需要特定的节点去查
3. 并发查询

## 主动更新缓存要注意的点

1. 不推荐先更新缓存再更新数据库，原因是数据库操作可能失败，导致缓存与数据库不一致；
2. 不推荐先更新数据库再更新缓存，原因是两者更新数据的顺序可能不一致，更新到缓存的数据也不一定被访问；
3. 不推荐先删缓存再更新数据库，访问时再进行加载，原因是并发情况下，删除缓存后来不及更新数据库，但旧值已经被其他线程读到了，或者数据库操作失败了，但缓存已经没了，其他导致还要再读一次数据库；
3. 推荐先更新数据库再删除缓存，访问时再进行加载，虽然也可能出现3中的情况，导致数据不一致，但带来的影响会相对小一些，如果删除缓存失败了，可以延迟任务进行删除重试，因为删除操作一般是幂等的，所以即使重复删除也没关系

