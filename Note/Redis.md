# 数据类型及结构

## string



## list



## set



## hash



## zset



[一文揭秘单线程的Redis为什么这么快?](https://zhuanlan.zhihu.com/p/57089960?utm_source=wechat_session&utm_medium=social&utm_oi=632939468966072320)

# 与Memcached的区别

* Redis支持存储多种数据类型：string、list、hash、set、zset；而Memcached只支持string

* Redis支持持久化：RDB快照和AOF日志；Memcached不支持持久化

* Redis支持事务，使用MULTI 和 EXEC命令，支持流水线式发送命令 ；Memcahced不支持事务，命令只能一条一条的发

* Redis-Cluster 支持分布式存储，可以多台Redis服务器存储同样的数据；Memcached是以**一致性哈希算法**实现分布式存储，即多台Memcached服务器，Memcached根据查找的key计算出该数据在哪台服务器上

* 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘； 

  Memcached 的数据则会一直在内存中，Memcached使用固定空间分配，将内存分为一组大小不同的slab_class，每个slab_class又分为一组大小相同的slab，每个slab又包含一组大小相同的chunk，根据数据大小，放到不同的chunk里，这种管理方式避免内存碎片管理问题，但是会带来内存浪费，即每个chunk内会放小于这个chunk大小的数据，chunk里有些空间没利用到

  一致性哈希算法：构造一个长度为2的32次方的整数环，根据结点名称的Hash值([0，2^32-1])，将结点放置在这个Hash环上，根据数据的key值计算Hash值，在Hash环上顺时针查找距离这个Key的Hash值最近的结点，完成key到结点的Hash映射查找，这样当扩容结点时，只会影响到其中一个结点；为了解决负载不均衡问题，可以在此基础上增加一个虚拟层，key先在环上找到虚拟结点，再找到物理结点，将数据分散到各个结点，一般一个物理结点对应150个虚拟结点

# 过期时间和数据淘汰策略

# 持久化

## 1. RDB快照

bgsave，会调子进程创建快照写入磁盘，父进程继续处理其他命令请求

save，主线程创建快照写入磁盘，会阻塞其他命令请求

redis.conf配置里，save [时间] [次数] 表示在[时间]内有[次数]写入，就会触发bgsave命令

另外，在进行主从复制，主redis发生sync命令给从redis时，如果刚刚没有执行完bgsave，也会进行一次bgsave操作

## 2. AOF

写命令记录到文件中



# 事务

# 缓存可能引发的问题以及应对方法

## 缓存雪崩

缓存大面积失效导致请求到达数据库

应对方法：

1. 缓存过期时间设置均匀，不能让一大片缓存在某一时间全部失效
2. 请求时加锁，后续请求只能等到前面的查完数据库，进行缓存后，才能继续，但会造成吞吐量降低，响应时间变长

## 缓存穿透

查询一个一定不存在的数据，导致请求一直到达数据库

应对方法：

1. 将可能出现查询的值哈希到一个bitMap中，使用布隆过滤进行拦截
2. 如果查询结果为空，也加入缓存中，每次查询返回空，设置过期时间

