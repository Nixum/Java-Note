- [消息队列](#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)
  - [常见消息队列](#%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)
  - [消息模型](#%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B)
  - [好处](#%E5%A5%BD%E5%A4%84)
  - [缺点](#%E7%BC%BA%E7%82%B9)
  - [常见问题](#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98)

[TOC]

# 消息队列

## 常见消息队列

| 特性                    | ActiveMQ                                                     | RabbitMQ                                                     | RocketMQ                                                     | Kafaka                                                       |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单机吞吐量              | 万级，吞吐量比RocketMQ和Kafka要低了一个数量级                | 万级，吞吐量比RocketMQ和Kafka要低了一个数量级                | 10万级，RocketMQ也是可以支撑高吞吐的一种MQ                   | 10万级别，这是kafka最大的优点，就是吞吐量高。一般配合大数据类的系统来进行实时数据计算、日志采集等场景 |
| topic数量对吞吐量的影响 |                                                              |                                                              | topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic | topic从几十个到几百个的时候，吞吐量会大幅度下降。所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源 |
| 可用性                  | 高，基于主从架构实现高可用性                                 | 高，基于主从架构实现高可用性                                 | 非常高，分布式架构                                           | 非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |
| 消息可靠性              | 有较低的概率丢失数据                                         |                                                              | 经过参数优化配置，可以做到0丢失                              | 经过参数优化配置，消息可以做到0丢失                          |
| 时效性                  | ms级                                                         | 微秒级，这是rabbitmq的一大特点，延迟是最低的                 | ms级                                                         | 延迟在ms级以内                                               |
| 功能支持                | MQ领域的功能极其完备                                         | 基于erlang开发，所以并发能力很强，性能极其好，延时很低       | MQ功能较为完善，还是分布式的，扩展性好                       | 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 |
| 优劣势总结              | 非常成熟，功能强大，在业内大量的公司以及项目中都有应用。偶尔会有较低概率丢失消息，而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用 | erlang语言开发，性能极其好，延时很低；吞吐量到万级，MQ功能比较完备而且开源提供的管理界面非常棒，用起来很好用。社区相对比较活跃，几乎每个月都发布几个版本分在国内一些互联网公司近几年用rabbitmq也比较多一些但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。 | 接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障。日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景。而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控。社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的 | kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量。而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。 |

## 消息模型

1.点对点：队列、监听器

2.发布订阅：监听器、监听器、观察者模式

## 好处

流量削峰、异步处理、解耦

## 缺点

可用性降低、复杂度提高、一致性问题

## 常见问题


以下问题都是需要分具体的MQ的，这里简单说下通用方法

- 引入消息队列之后如何保证高可用性

  集群 + zookeeper + 负载均衡

以ActiveMQ为例

使用ZooKeeper（集群）注册所有的ActiveMQ Broker。只有其中的一个Broker可以提供服务，被视为 Master，其他的 Broker 处于待机状态，被视为Slave。如果Master因故障而不能提供服务，Zookeeper会从Slave中选举出一个Broker充当Master。
Slave连接Master并同步他们的存储状态，Slave不接受客户端连接。所有的存储操作都将被复制到 连接至 Master的Slaves。如果Master挂了，得到了最新更新的Slave会成为 Master。故障节点在恢复后会重新加入到集群中并连接Master进入Slave模式

集群数据共享可采用 文件共享 或 数据库共享 或 可复制的LevelDB

- 如何保证消息不被重复消费（幂等性）呢？

  一种是消息被重复消费也无所谓，另一种是消费者处理消息的时候将消息入库记录（通过消息id + redis/MySQL）；对于无法处理的消息导致MQ重复发送，可以设置重复次数，过了重复次数将消息持久化到其他地方，以后处理

- 如何保证消息的可靠性传输（如何处理消息丢失的问题）？

  持久化机制 + ack机制 或 事务机制(MQ提供，但是吞吐量低)

  生产者消息丢失处理：发送消息时产生一个id，MQ接收到消息后回传id，超过一定时间没收到则重发

  MQ消息丢失处理：开启消息队列持久化 和 消息持久化，持久化后才回传id给生产者

  消费者消息丢失处理：取消自动ack，在方法处理完之后调用方法，发送确认ack给MQ，如果消息处理的时间太长，但可能导致重复发送

  

  JMS的可靠性机制，默认是消息持久化、订阅持久化、消息不过期

  消息的成功消费包含三个阶段：客户接收消息、客户处理消息和消息被确认，也就是要确认这三个阶段能成功

  事务性会话 还是 非事务性会话，第一步和第二步都一样但第三步有所不同

  保证消息从生产者到MQ或者MQ到消费者的过程在同一个会话中，保证原子性；在事务性会话中，当一个事务被提交的时候，确认自动发生；事务回滚，消息再次传送；一个事务提交才能进行下个事务，效率较差。

  在非事务性会话中，消息何时被确认取决于创建会话时的应答模式ACK模式，分为自动确认(onMessage方法成功返回，如果抛异常会交由异常消息监听器，或者重复次数发送)、手动确认、不必须确认,批量(重复有标记)。

  > ACK模式描述了Consumer与broker确认消息的方式(时机),比如当消息被Consumer接收之后,Consumer将在何时确认消息。对于broker而言，只有接收到ACK指令,才会认为消息被正确的接收或者处理成功了,通过ACK，可以在consumer（producer）与Broker之间建立一种简单的“担保”机制. 

  参考[ActiveMQ消息传送机制以及ACK机制详解](https://shift-alt-ctrl.iteye.com/blog/2020182)

- 如何保证从消息队列里拿到的数据按顺序执行？

  生产者按顺序将消息入队

  消费者那边做处理，拆分多个队列，一个队列对应一个消费者；或者消费者创建多个不同线程处理不同的数据

  消费者根据消息版本号来执行

- 如何解决消息队列的延时以及过期失效问题？

  手动查询丢失消息，重新导入

  对于activeMQ，可以设置死信队列，过期或者重复多次为被消费的消息会进入死信队列，activeMQ有提供方法处理死信队列

- 消息队列满了以后该怎么处理，有几百万消息持续积压几小时，如何解决？

  修复消费者，恢复消费速度；

  扩充原来的数量，消费之后再恢复原来架构。比如新键一个topic，建立比原先多n倍的队列，多n倍的消费者处理，每批消费者对应一个队列；

  如果有持久化消息，可以先丢弃消息，之后再将持久化消息导入队列再处理

- 如果让你来开发一个消息队列中间件，你会怎么设计架构？

  主要是设计中间的消息转发，将一次RPC转化成两次RPC；选择通信协议；消息的可靠性确认；消息持久化；消息模型；事务特性；分布式集群特性等

  ![git流程](https://github.com/Nixum/Java-Note/blob/master/Note/picture/消息队列架构.jpg)

参考

[消息队列常见问题和解决方案](http://xuyangyang.club/articles/2018/07/23/1532348839398.html)

[如何从0到1设计一个MQ消息队列](http://youzhixueyuan.com/design-the-message-queue.html)

[架构文摘：消息队列设计精要](