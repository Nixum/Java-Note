# 常用SQL

* Count(\*)或者Count(1)或者Count([列])区别
  1. Count(\*)或者Count(1) 返回的数量都一样，count(\*)会引起全表扫描
  2. Count（列）会计算列或这列的组合不为空的计数。
  3. 假如表沒有主键(Primary key), 那么count(1)比count(\*)快，
  4. 如果有主键的話，那主键作为count的条件时候count(主键)最快
  5. 如果你的表只有一个字段的话那count(\*)就是最快的
  6. count(\*) 跟 count(1) 的结果一样，都包括对NULL的统计，而count(column) 是不包括NULL的统计

# 索引

## 1.常见索引及概念

* 聚集索引：每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据。一个表只能包含一个聚集索引，聚集索引通常提供更快的数据访问速度。
* 非聚集索引：表中行的物理顺序与键值的逻辑顺序不匹配，查到记录对应的主键值 ，再使用主键的值通过聚集索引查找到需要的数据，要细分的话可以分为普通索引，唯一索引，组合索引，全文索引这些。
* 稠密索引：每个索引对应一个值
* 稀疏索引：每个索引对应一个存储块
* 覆盖索引：要查询的字段只需要去查询索引表就可以

## 2.特点

需要建立的列：经常需要搜索的列、主键列、外键列、排序的列、经常在where后面出现的列

* 避免进行数据库全表的扫描，大多数情况，只需要扫描较少的索引页和数据页，而不是查询所有数据页。而且对于非聚集索引，有时不需要访问数据页即可得到数据。
* 聚集索引可以避免数据插入操作，集中于表的最后一个数据页面。
* 在某些情况下，索引可以避免排序操作
* 加速表与表之间的连接
* 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间
* 增，删，改会带来不小性能开销

## 3.原理

[什么是B+树、B-树](https://www.sohu.com/a/156886901_479559 "")

b+树：表的数据为叶子节点，非叶子节点为索引，有两条路径，一条是树，一条是各叶子相连	（mysql）
			                                           31 52
		                  15 22 31                                                47 52
	10-12-15-----18-19-20-22----23-30-31---------33 45 47-------48 50 52

b-树：所有节点为表的数据，只有一条路，从根节点开始
                                                                                10
                                                            3    6                        13                     16
                                                    1 2   4 5   7 8 9      11 12    14 15    17 18 19 20

## 4.优化

* 注意区分度，使用这个计算 count(distinct  left(列名,  索引长度))/count(*) from table，区分度越高越好
* 其他参考

# 存储引擎

## 1.MyISAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

不支持事务。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

## 2.InnoDB

是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

## 3.区别

* MyISAM是非事务安全，InnoDB是事务安全型
* MyISAM的锁是表锁，InnoDB支持行锁
* MyISAM支持全文索引，InnoDB不支持
* MyISAM相对简单，效率上优于InnoDB，MyISAM读的快，InnoDB改的快
* MyISAM表是保存成文件形式，跨平台转移方便
* InnoDB表比MyISAM表安全
* MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢
* InnoDB 支持外键，InnoDB 支持在线热备份

# 事务

## 1.ACID原则

原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）

* 原子性：事务中的所有操作要么全部提交成功，要么全部失败回滚
* 一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态
* 隔离性：一个事务所做的修改在最终提交以前，对其他事务是不可见的
* 持久性：一旦事务提交，则其所做的修改不会永久保存到数据库

## 2.并发情况下带来的问题

* 脏读：如有事务A和B，A读取了B未提交的数据
* 不可重复读：如有事务A和B，A负责读取，B负责写入，A连续读的过程中B写入了一次，A前后两次读出来的数据不一样
* 丢失更新：如有事务A和B，AB均写入数据，A写入的数据被B覆盖
* 幻读：如有事务A和B，A修改表内数据的过程中，B向表内插入了一条数据，A修改完后发现数据并没有被全部修改完

## 3.事务隔离级别

* DEFAULT：默认隔离级别，即使用底层数据库默认的隔离级别；
* READ_UNCOMMITTED：未提交读，保证了读取过程中不会读取到非法数据。隔离级别在于处理多事务的并发问题，可能出现 脏读、不可重复读、丢失更新、幻读；
* READ_COMMITTED：提交读，大多数主流数据库的默认事务等级，保证了一个事务不会 读 到另一个并行事务已修改但未提交的数据，避免了“脏读”。该级别适用于大多数系统，可能出现不可重复读、丢失更新；
* REPEATABLE_READ：可重复读，保证了一个事务不会 修改 已经由另一个事务读取但未提交（回滚）的数据。避免了"脏读"和"不可重复读取"，"丢失更新"的情况，可能存在幻读；mysql默认是此隔离级别
* SERIALIZABLE：序列化,最严格的级别，事务串行执行,即一个事务要等待另一个事务完成才可进行

## 4.传播行为（Spring）



# 参考

[MySQL ACID及四种隔离级别的解释](https://www.cnblogs.com/xuanzhi201111/p/4103696.html)

[CyC2018/CS-Notes/MySQL](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md)