# 常用SQL

* Count(\*)或者Count(1)或者Count([列])区别
  1. Count(\*)或者Count(1) 返回的数量都一样，count(\*)会引起全表扫描
  2. Count（列）会计算列或这列的组合不为空的计数。
  3. 假如表沒有主键(Primary key), 那么count(1)比count(\*)快，
  4. 如果有主键的話，那主键作为count的条件时候count(主键)最快
  5. 如果你的表只有一个字段的话那count(\*)就是最快的
  6. count(\*) 跟 count(1) 的结果一样，都包括对NULL的统计，而count(column) 是不包括NULL的统计

# 索引

## 1.常见索引及概念

* 聚集索引：表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引，聚集索引通常提供更快的数据访问速度。
* 非聚集索引：表中行的物理顺序与键值的逻辑顺序不匹配，查到记录对应的主键值 ，再使用主键的值通过聚集索引查找到需要的数据。
* 稠密索引：每个索引对应一个值
* 稀疏索引：每个索引对应一个存储块
* 覆盖索引：比如，给表的字段A，B添加索引，当要查询B时，只需要查询A就能得出B，而不需要查到A，拿到id在查B

## 2.特点

需要建立的列：经常需要搜索的列、主键列、外键列、排序的列、经常在where后面出现的列

* 避免进行数据库全表的扫描，大多数情况，只需要扫描较少的索引页和数据页，而不是查询所有数据页。而且对于非聚集索引，有时不需要访问数据页即可得到数据。
* 聚集索引可以避免数据插入操作，集中于表的最后一个数据页面。
* 在某些情况下，索引可以避免排序操作
* 加速表与表之间的连接
* 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间
* 增，删，改会带来不小性能开销

## 3.原理

b+树：表的数据为叶子节点，非叶子节点为索引，有两条路径，一条是树，一条是各叶子相连	（mysql）
			                      31 52
		       15 22 21                                         47 52
	10 12 15     18 19 20 22      23 30 31       33 45 47       48 50 52

b-1树：所有节点为表的数据，只有一条路，从根节点开始
                                                                                10
                                                            3    6                        13          16
                                                     1 2   4 5   7 8 9      11 12    14 15    17 18 19 20

# 存储引擎

## 1.MyISAM

## 2.InnoDB

# 事务

## 1.并发情况下带来的问题

* 脏读：如有事务A和B，A读取了B未提交的数据
* 不可重复读：如有事务A和B，A负责读取，B负责写入，A连续读的过程中B写入了一次，A前后两次读出来的数据不一样
* 丢失更新：如有事务A和B，AB均写入数据，A写入的数据被B覆盖
* 幻读：如有事务A和B，A修改表内数据的过程中，B向表内插入了一条数据，A修改完后发现数据并没有被全部修改完

## 2.事务隔离级别

* DEFAULT：默认隔离级别，即使用底层数据库默认的隔离级别；
* READ_UNCOMMITTED：未提交读，保证了读取过程中不会读取到非法数据。隔离级别在于处理多事务的并发问题，可能出现 脏读、不可重复读、丢失更新、幻读；
* READ_COMMITTED：提交读，大多数主流数据库的默认事务等级，保证了一个事务不会 读 到另一个并行事务已修改但未提交的数据，避免了“脏读”。该级别适用于大多数系统，可能出现不可重复读、丢失更新；
* REPEATABLE_READ：可重复读，保证了一个事务不会 修改 已经由另一个事务读取但未提交（回滚）的数据。避免了"脏读"和"不可重复读取"，"丢失更新"的情况，可能存在幻读；mysql默认是此隔离级别
* SERIALIZABLE：序列化,最严格的级别，事务串行执行,即一个事务要等待另一个事务完成才可进行

## 3.传播行为（Spring）

