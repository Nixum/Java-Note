# 线程与进程的区别

## 进程

进程是资源分配的基本单位。

## 线程

线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。

## 区别

1. 拥有资源

   进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

2. 调度

   线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

3. 系统开销

   由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

4. 通信方面

   线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。



# 线程的状态

## 1.状态转换

![线程状态转换](https://github.com/Nixum/Java-Note/blob/master/Note/picture/线程状态转换.png)

“阻塞”与“等待”的区别：
“阻塞”状态是等待着获取到一个排他锁，进入“阻塞”状态都是被动的，离开“阻塞”状态是因为其它线程释放了锁，不阻塞了；
“等待”状态是在等待一段时间 或者 唤醒动作的发生，进入“等待”状态是主动的

## 2. 状态

* New（新建）：通过new创建一个新线程，但还没运行，还有一些其他基础工作要做
* Runnable（可运行）：线程调用start方法，可能处于正在运行也可能处于没有运行，取决于操作系统提供的运行时间
* Blocked（阻塞）：线程已经被挂起，等待锁的释放，直到另一个线程走完临界区或发生了相应锁对象wait()操作后，它才有机会去争夺进入临界区的权利
  1. 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。
  2. 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
  3. 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
* Waiting（无限期等待）： 处于此状态的线程会等待另外一个线程，不会被分配CPU执行时间，直到被其他线程唤醒
  1. 没有设置timeout参数的Object.wait()
  2. 没有设置timeout参数的Thread.join()
  3. LockSupport.park() 以上方法会使线程进入无限等待状态
* Timed_waiting（限期等待）：不会被分配CPU执行时间，不过无需等待被其它线程显示的唤醒
  1. Thread.sleep()方法
  2. 设置了timeout参数的Object.wait()方法
  3. 设置了timeout参数的Thread.join()方法
  4. LockSupport.parkNanos()方法
  5. LockSupport.parkUntil()方法
* TERMINATED（结束）：已终止线程的线程状态，线程已经结束执行，run()方法走完了，线程就处于这种状态或者出现没有捕获异常终止run方法意外死亡

# 一些锁的概念



# JUC包内的一些类

## 原子操作类

## 基本

多线程下，java 自增自减操作是线程不安全的，因此JUC包才提供了线程安全的原子操作类

## 原理

CAS + 自旋保证

[AtomicInteger源码分析——基于CAS的乐观锁实现](https://blog.csdn.net/qfycc92/article/details/46489553 "")