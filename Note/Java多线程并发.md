# 线程与进程的区别

## 进程

进程是资源分配的基本单位。

## 线程

线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。

## 区别

1. 拥有资源

   进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

2. 调度

   线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

3. 系统开销

   由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

4. 通信方面

   线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。



# 线程的状态

## 1.状态转换

![线程状态转换](https://github.com/Nixum/Java-Note/blob/master/Note/picture/线程状态转换.png)

“阻塞”与“等待”的区别：
“阻塞”状态是等待着获取到一个排他锁，进入“阻塞”状态都是被动的，离开“阻塞”状态是因为其它线程释放了锁，不阻塞了；
“等待”状态是在等待一段时间 或者 唤醒动作的发生，进入“等待”状态是主动的

## 2. 状态

* New（新建）：通过new创建一个新线程，但还没运行，还有一些其他基础工作要做
* Runnable（可运行，就绪）：线程调用start方法，可能处于正在运行也可能处于没有运行，取决于操作系统提供的运行时间
* Running（运行）
* Blocked（阻塞）：线程已经被挂起，等待锁的释放，直到另一个线程走完临界区或发生了相应锁对象wait()操作后，它才有机会去争夺进入临界区的权利
  1. 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。
  2. 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
  3. 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
* Waiting（无限期等待）： 处于此状态的线程会等待另外一个线程，不会被分配CPU执行时间，直到被其他线程唤醒
  1. 没有设置timeout参数的Object.wait()
  2. 没有设置timeout参数的Thread.join()
  3. LockSupport.park() 以上方法会使线程进入无限等待状态
* Timed_waiting（限期等待）：不会被分配CPU执行时间，不过无需等待被其它线程显示的唤醒
  1. Thread.sleep()方法
  2. 设置了timeout参数的Object.wait()方法
  3. 设置了timeout参数的Thread.join()方法
  4. LockSupport.parkNanos()方法
  5. LockSupport.parkUntil()方法
* TERMINATED（结束，死亡）：已终止线程的线程状态，线程已经结束执行，run()方法走完了，线程就处于这种状态或者出现没有捕获异常终止run方法意外死亡

# Object和Thread中关于线程的一些方法

## Object类中wait()和notify()、notifyAll()

* wait()使得线程进入等待状态，同时释放锁，等待其他线程notify()、notifyAll()的唤醒

  因为wait()和notify()、notifyAll()是对象中的方法，如果wait()没有释放锁，其他线程就无法获得锁进入同步代码块中，也就无法执行notify()或者notifyAll()方法唤醒挂起的线程，造成死锁

* 这套方法只能在同步块synchronized中使用，否则会抛IllegalMonitorStateException异常

* wait() 方法可以设置时间，时间到了也会进入就绪状态

* notify()方法只会随机唤醒某个在等待的线程，notifyAll()方法是唤醒全部

* 可响应中断

为什么操作线程的方法wait()和notify()、notifyAll()是Object类中的？

java提供的锁是对象级别的，等待需要锁，把每个对象看成一个锁，同一个对象可以放入不同的线程中，从而达到不同线程可以等待或唤醒，如果是线程里的方法，当前线程可能会等待多个线程的锁，这样操作比较复杂

## Thread中的yield()

* 静态方法
* yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权
* 该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权，也有可能是当前线程又进入到“运行状态”继续运行

## Thread中的 suspend() 和resume()

* 不是静态方法

* suspend()用于挂起线程， resume() 用于唤醒线程，需要配套使用，这两个方法被标为**过期，不推荐**
* suspend() 在导致线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行 resume() 方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行
* 如果 resume() 操作出现在 suspend() 之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。而且，对于被挂起的线程，它的线程状态居然还是 Runnable

## Thread类中的sleep()方法

* 静态方法
* 使当前正在执行的线程进入休眠（阻塞），不会释放锁，单位是毫秒
* sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理
* 可响应中断

## Thread类中的join()方法

* 不是静态方法
* 在线程中调用另一个线程的 join() 方法，会将当前线程挂起（阻塞），而不是一直等待，直到目标线程结束
* 没有释放锁
* 可响应中断

## Condition类中的await()和signal()、signalAll()

* Condition类中的await()和signal()、signalAll()用来代替传统Object里的wait()和notify()、notifyAll()方法，作用基本相同
* await()可以指定条件，Condition类中的await()和signal()、signalAll()会更加灵活
* Condition配合Lock(ReentrantLock)使用，Lock 可以用来获取一个 Condition对象、还有加锁解锁，阻塞队列中就使用了Condition来模拟线程间协作

# 中断

参考[Java并发--InterruptedException机制](https://blog.csdn.net/meiliangdeng1990/article/details/80559012 )

# 关键字

## synchronized

* 当synchronized(xxx.class)锁住的是类时，多个线程访问不同对象(它们同类),就会锁住代码段，当一个线程执行完这个代码段后才轮到别的线程，可以理解成全局锁
* 当synchronized(object)锁住的是对象时，多个线程访问不同对象(它们同类),它们相互之间并不影响，只有当多个线程访问同一对象时，才会锁住代码段，等到一个线程执行完之后才轮到别的线程执行
* 当synchronized(this)锁住的是当前的对象，当synchronized块里的内容执行完之后，释放当前对象的锁。同一时刻若有多个线程访问这个对象，则会被阻塞
* synchronized下不可被中断
* synchronized是非公平锁

在用synchronized关键字的时候，尽量缩小代码段的范围，能在代码段上加同步就不要再整个方法上加同步，减小锁的粒度，使代码更大程度的并发，如果锁的代码段太长了，别的线程等得就久一点

## volatile

* 保证此变量对所有线程的可见性，即当以线程修改这个变量的值，新值对其他线程可知，volatile只能保证可见性
  由于java里的运算不是原子性，所有volatile变量的运算在并发下一样不安全
  当出现
       运算结构不依赖变量的当前值，或能确保只有单一的线程修改变量的值
       变量不需要与其他的状态变量共同参与不变约束
  此时需要加锁
* 禁止指令重排序优化，普通变量只会保证该方法执行过程中所依赖赋值的结果都能获得正确的结果，不能保证变量赋值操作的顺序与程序代码的执行顺序一致

典型用法是 检查某个状态标记以判断是否退出循环

# 一些锁的概念



# JUC包内的一些类

## 原子操作类

### 基本

多线程下，java 自增自减操作是线程不安全的，因此JUC包才提供了线程安全的原子操作类

### 原理

CAS + 自旋保证

[AtomicInteger源码分析——基于CAS的乐观锁实现](https://blog.csdn.net/qfycc92/article/details/46489553 "")

[过期的suspend()挂起、resume()继续执行线程](https://www.cnblogs.com/zhengbin/p/6505971.html)