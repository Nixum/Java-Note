## 理论

### 分布式系统的三个指标

CAP定理

## 2PC

需要有协调者和参与者，协调者负责调度，参与者负责执行，分两步完成，1：prepare阶段 2：commit阶段

在执行阶段，节点是处于阻塞状态，直到commit阶段完成，本地事务才会释放资源，因此性能不佳



### 正常情况下

**prepare阶段**：协调者向参与者A、B发送请求执行操作，参与者A、B开启事务，执行操作，但不commit，操作完成后，告诉协调者已经完成

**commit阶段：**协调者收到参与者的完成响应，向参与者A、B发送commit请求，参与者A、B收到commit请求后，提交事务，完成操作；如果收到执行失败的响应，则发送回滚请求给参与者A、B，执行回滚

### 异常情况下

在协调者等待参与者的完成响应时，协调者或参与者可能宕机，最终会导致数据不一致或阻塞，例如

当处于prepare阶段和commit阶段之间时，协调者挂掉(或挂掉后重启)，会导致协调者收不到参与者的响应，此时协调者就不清楚接下来的commit要发送什么请求过去，或者就不发请求过去了，导致参与者一直阻塞

**解决办法：**协调者维护一份事务日志，以方便宕机重启后恢复原来的状态，但无法为参与者设置超时自动操作，因为它并不知道commit阶段自己要进行commit还是回滚

当处于prepare阶段和commit阶段之间时，参与者挂掉后，接收不到协调者的请求，不知道接下来要执行commit还是回滚，协调者也无法在参与者挂掉后进行回滚操作

**解决办法：**3pc

## 3PC

3pc实际上就是将commit阶段拆成两步，preCommit相当于一次保险阶段，作用类似于2pc的二阶段，但是它不是正真的提交

### 正常情况下

**canCommit阶段：**协调者向参与者发送请求，参与者开启事务执行操作，成功完成后响应Yes，否则响应No

**preCommit阶段：**协调者收到所有参与者的Yes响应，发送操作请求给所有参与者，告诉所有参与者进行预提交状态

**commit阶段：**协调者收到所有参与者的应答响应，向所有参与者发送commit请求，参与者收到后提交事务

### 异常情况下

如果在preCommit阶段到commit阶段之间，协调者挂了，参与者会在超时后进行事务提交

## TCC

补偿事务，每一个操作都要有对应的确认和补偿，类似于2pc，但2pc在于DB层面，TCC在于业务层面，每个业务逻辑都需要实现try-confirm-cancel的操作

**Try阶段**：对于操作的数据行，增加字段表示其状态，表示正在操作

**confirm阶段**：将try阶段中表示数据状态的字段修改为确认状态，表示已经完成操作，操作需要幂等

**cancel阶段**：将try阶段进行的操作进行回滚

通过不断重试，并发的时候还是需要分布式锁

## SAGA



## 利用RocketMQ事务

事务性消息：本地事务和发送消息是原子性操作

https://www.jianshu.com/p/53324ea2df92

http://blog.itpub.net/31556438/viewspace-2649246/



## 阿里云分布式事务GTS






## 参考：

[2pc、3pc](https://zhuanlan.zhihu.com/p/21994882)

[TCC](https://juejin.im/post/5bf201f7f265da610f63528a)

[TCC](https://yemablog.com/posts/tcc-1)

[华为的servicecomb](https://blog.csdn.net/weixin_42075590/article/details/89236625)

[蚂蚁金服的seata分布式事务架构](https://www.sofastack.tech/blog/sofa-meetup-3-seata-retrospect/)