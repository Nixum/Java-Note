- [从浏览器输入URL之后都发生了什么](#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E4%B9%8B%E5%90%8E%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88)
- [HTTP方法](#http%E6%96%B9%E6%B3%95)
  - [Get和Post的区别](#get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB)
- [常见状态码](#%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81)
- [HTTPs](#https)
- [TCP（Transmission Control Protocol 传输控制协议）](#tcptransmission-control-protocol-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)
  - [特点](#%E7%89%B9%E7%82%B9)
  - [连接与关闭连接](#%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5)
    - [三次握手](#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)
    - [四次挥手](#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
  - [滑动窗口](#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3)
  - [拥塞控制](#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)
- [UDP（User Datagram Protocol 用户数据报协议）](#udpuser-datagram-protocol-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE)
  - [特点](#%E7%89%B9%E7%82%B9-1)
- [参考](#%E5%8F%82%E8%80%83)



[TOC]

# 从浏览器输入URL之后都发生了什么

浏览器输入URL，按回车，

1. 首先根据域名，找到对应的IP地址，依次经过浏览器缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索DNS服务器

2. 建立 TCP/IP 连接（三次握手具体过程）
3. 由浏览器发送一个 HTTP 请求
4. 经过路由器的转发，通过服务器（CDN、反向代理之类的）的防火墙，该 HTTP 请求到达了服务器
5. 服务器处理该 HTTP 请求，返回一个 HTML 文件
6. 浏览器解析该 HTML 文件，并且显示在浏览器端

# HTTP方法

[菜鸟HTTP教程/HTTP请求方法](http://www.runoob.com/http/http-methods.html "")

## Get和Post的区别

[99%的人都理解错了HTTP中GET与POST的区别](https://zhuanlan.zhihu.com/p/22536382 "")

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的（1024个字节即256个字符），而POST没有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中

幂等性：同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的，每次返回的结果一样，不产生副作用；

根据语义，简单的把get看成查询，只要服务器的数据没变，每次查询得到的结果是一样的，而把post看成添加，每次post请求都会创建新资源，服务器状态改变

关于幂等性和安全性的文章：[HTTP方法的安全性和幂等性](https://blog.csdn.net/qq_15037231/article/details/78051806 "")

具有幂等性的方法：GET、HEAD、OPTIONS、DELETE、PUT

没有幂等性的方法：POST

安全性：安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。

# 常见状态码

参考[HTTP状态码](http://www.runoob.com/http/http-status-codes.html)

# HTTPs

HTTPS = HTTP + SSL，SSL提供 加密明文，验证身份，保证报文完整 的保障

HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信

* 加密

  使用 对称加密 加密 报文(私钥加密私钥解密)，使用 非对称加密 (公钥加密私钥解密)加密 对称加密的密钥 保证该密钥的传输安全

* 验证身份

  通过第三方（CA）发布证书，对通信方进行认证

  服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

  进行 HTTPs 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了，通信时使用上述的加密机制保护报文

* 保护报文完整

  SSL 提供报文摘要功能结合加密和认证来进行完整性保护

流程：

在HTTP的基础上  
客户端访问服务端的网页，首先经过浏览器内置的受信任的CA机构列表，查看该服务器是否向CA机构提供了证书，如果服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，建立会话密钥，客户端通过服务器公钥加密会话密钥发送给服务端，服务端用自己私钥解密得到会话密钥，用于接收和发送数据，之后传输的http数据都是经过加密的。
非对称加密的手段传递密钥，然后用密钥进行对称加密传递数据

# TCP（Transmission Control Protocol 传输控制协议）

## 特点

* 面向连接的，提供可靠交付，丢包重传
* 有流量控制，拥塞控制
* 提供全双工通信
* 面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）
* 头部20字节
* 每一条 TCP 连接只能是点对点的（一对一）。

## 连接与关闭连接

SYN：发起一个新连接 	ACK：确认序号有效
FIN：释放一个连接		ack：确认序号，=发送方seq+1

### 三次握手

![三次握手](https://github.com/Nixum/Java-Note/blob/master/Note/picture/三次握手.jpg)

（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 每一端先发出去的都会由SYN，收到之后会发出ACK
（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 
（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

### 四次挥手

![四次挥手](https://github.com/Nixum/Java-Note/blob/master/Note/picture/四次挥手.jpg)

由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭
（1）第一次挥手：Client发送一个FIN、一个seq，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 
（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号ack为收到seq+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 
（3）第三次挥手：Server发送一个FIN、一个ACK、ack为上面的seq+1、一个seq，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 
（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 

* 为什么不能用两次握手进行连接？

  如果两次握手确定连接，有可能发生死锁，比如server发送连接请求给client，client接收后发送请求给server，此时连接建立，server可以正常的发送和接收，但是client并不知道自己发送的请求server有没有收到，那它会认为没有确立连接，一直等待server的确认信号，忽略其他数据，server发出的数据被忽略，则会一直发送

* 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？ 

  因为TCP是全双工的

  三次握手：发送一次信息就是一次握手，第一次握手确定Client可以发送消息给Server，第二次握手确定Server可以收到Client的信息，并且发送信息给Client，第三次握手Client确定可以收到Server的信息，三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

  四次挥手：第一次挥手Client发送消息确定Client想关闭连接，第二次挥手Server发送消息确定Client可以关闭连接，第三次挥手Server发送消息确定Server想关闭连接，第四次挥手Client发送消息确定Server可以关闭连接，少了哪一次都可能导致没有完全关闭，造成一方可发送或者接受。

  之所以要四次，是因为server收到Fin后，不能同时将ACK确认信号和FIN，有可能此时有一些报文还没收完，所以FIN和ACK要分开发

  详细解释是服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

* 为什么client在发送最后一个ACK后进入Time-wait状态，为什么Time-wait状态必须等待2MSL的时间？
  （1）为了保证client发送的最后一个ACK报文能到达server。这个ACK报文可能丢失，此时server接收不到，那他就会重新发送FIN+ACK报文，client就能在这2MSL内收到这个重传的报文，再次进入2MSL等待时间，发送ACK给server，直到两者都进入closed状态。如果没有2MSL等待时间，而是client发送完报文直接关闭，有可能会出现server无法接收而导致无法进入closed状态。
  （2）client在发送完最后一个ACK报文段后，在经过2MSL，就可以使本连接持续的时间内所产生的所有报文都从网络消失，使得下一个新的连接不会出现旧的连接请求报文

* 建立连接后出故障了怎么办？

  TCP设有一个保活计时器，每收到一次请求都会复位这个计时器，如果规定时间(2小时)内没收到，则发送探测报文测试对方是否出现故障，连续10次/75分钟，仍没反应，说明对方故障	

## 滑动窗口

窗口大小即自己的数据接收缓冲池的大小

由发送方和接收方在三次握手阶段，**互相**通知自己的最大可接收的字节数。

当发送方窗口左部字节已发送且收到通知，窗口右滑直到左部第一个字节不是已发送并且已确认的状态，接受方窗口移动同理

接收窗口只会对窗口内最后一个按序到达的字节进行确认，确认之后表示之前的所有字节都接收到了

在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。

**粘包问题：**

发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

只有TCP会，UDP因为有消息边界，所以不会

产生的原因：

​	发送端粘包：发送端等到缓冲区满了才发送出去，造成粘包

​	接受端粘包：接受端不及时接收缓冲区的包，造成多个包接收

解决方法：

​	发送固定长度的消息、消息尺寸和消息一块发送、特殊标记标记消息区间

​	程序控制发送和接收频率

[TCP粘包问题分析和解决（全）](https://www.cnblogs.com/kex1n/p/6502002.html)

## 拥塞控制

拥塞：对资源的需求超过了可用的资源，网络吞吐量下降

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。

流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

拥塞控制方法：慢开始 + 拥塞避免、 快重传 + 快恢复

# UDP（User Datagram Protocol 用户数据报协议）

## 特点

* 不可靠的、无连接的，尽最大可能交付，只负责发送数据
* 没有拥塞控制
* 面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）
* 头部只有8字节
* 支持一对一、一对多、多对一和多对多的交互通信。

# 参考

[TCP/IP参考1](https://blog.csdn.net/jungle_hello/article/details/51465119 "")  

[TCP/IP参考2](https://blog.csdn.net/qq_18425655/article/details/52163228 "")